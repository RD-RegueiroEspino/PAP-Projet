\documentclass[11pt,a4paper]{article}

\usepackage[papersize={210mm,297mm},lmargin=3cm,rmargin=3cm,top=4cm,bottom=4cm]{geometry}

\renewcommand{\baselinestretch}{1.25}

\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{latexsym,pdfsync,xcolor,graphicx}
\usepackage[nottoc]{tocbibind}
\usepackage{hyperref}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{tikz}
\usepackage{appendix}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{float}

\newcommand{\portada}[3]{
	\thispagestyle{empty}
	
	\definecolor{zulon}{rgb}{0,.25,.5}
	
	
	
	\vspace*{.9cm}
	
	\centerline{{\Large\bf  Rapport Projet PAP}}
	
	\vspace{2.6cm}
	
	{\center{\Huge\bfseries\color{zulon} #1}\par}			
	
	\vspace{1cm}
	
	{\Large
		\centerline{#2}			
		
		\vspace{6.4cm}
		\centering{\includegraphics[width=4cm]{Images/ensiie.jpg}}
		\centerline{\sf #3}
		
		\vspace{1.25cm}
		
		\centerline{\sf École Nationale Supérieure d’Informatique pour l’Industrie et l’Entreprise}
	}
	
	\enlargethispage{1cm}
	\clearpage
}

\begin{document}
	\portada
	{Courbes de Bézier et police de caractères}
	{Ramón Daniel Regueiro Espiño \& Bastien Tridon}
	{2021/2022}
	\thispagestyle{empty}
	
	\tableofcontents
	\thispagestyle{empty}
	
	\mbox{}
	
	\clearpage
	\section{Introduction}
	La représentation de caractères dans les écrans de nos ordinateurs en utilisant les bitmaps possèdent de multiples usages, par exemple, le sous-titrage des films. Généralement, pour leur simplicité et leur facilité de lecture dans le cas où la résolution n'est pas très haute, les polices sans serif sont les plus utilisés.\\
	
	En conséquence, l'objectif de ce projet est de représenter des polices de caractères sans serif en majuscule. On essayera de les créer de sorte que l'on puisse faire varier la taille des bitmaps. Pour réduire l'effet de la taille on utilisera des courbes de Bézier pour la création des polices de caractères. L'avantage principale de ces courbes est qu'on peut créer des bitmaps de différentes tailles en maintenant la structure de nos lettres grâce à l'utilisation de points de contrôle prédéfinis.\\
	
	La programmation de la représentation de chaque bitmap se fera dans le langage C++ et à l'aide de la bibliothèque SDL. On considérera trois étapes différenciées: la création d'une lettre "vide", le remplissage de l'intérieur et le contour en rouge. La raison de l'inclusion de la dernière étape permet que les lettres restent bien visibles même si la couleur du support change.
	
	
	\newpage
	\section{Structure}
	Dans cette section on expliquera brièvement la structure de notre projet. Pour une meilleure compréhension de cette structure, on a ajouté le diagramme UML dans la Figure \ref{im:uml}. On peut remarquer que notre projet est composé de 5 classes.
	
	\subsection{Diagramme UML}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=0.95\linewidth]{Images/uml.png}
		\caption{Diagramme UML du projet}
		\label{im:uml}
	\end{figure}
	
	\subsection{Description de la structure}
	Tout d'abord, on a créé une classe R2 qui répresente $\mathbb{R}^2$ pour l'appliquer à l'algorithme de Casteljau. Cette classe est celle que l'on utilisera comme base de notre projet, pour la majorité des autres classes, on créera des objets de R2. De plus, on ajoute des opérateurs nécessaires pour notre projet: sommation et soustraction de deux éléments de R2 et multiplication par double.\\
	
	Ensuite, on a codé l'algorithme de Casteljau dans une classe héritant de R2 appelée Casteljau. Cette classe nous permettra de développer une fonction \texttt{pointcourbe(T: Casteljau \&,t: const double)} pour calculer la valeur de la courbe de Bézier considérée en $t \in [0,1]$.\\
	
	Par ailleurs, pour faire en même temps tous les calculs de $t$ qu'on considère, on a créé une classe appelée Remplissage. L'idée de cette classe est la création de la fonction \texttt{Calcul(E: Casteljau,T: Remplissage)} pour calculer toutes les valeurs considérées de notre courbe, c'est-à-dire, tous les $t$ considérés.\\
	
	Après, pour avoir une représentation sous forme de tableau, avant d'ajouter la bibliotéque SDL, et pour le cas où le terminal ne peut pas l'utiliser, on pourra imprimer ici une version du bitmap final composé de 0 de 1 et de 2, pour les trois couleurs blanc, noir et rouge respectivement.\\
	
	Enfin, on a ajouté une classe \texttt{AffichageSDL} implémentant une unique fonction \texttt{Dessine} afin de simplifier l'usage que l'on fait de la bibliothèque SDL. Cette classe, permet à partir d'un bitmap d'une lettre, de créer la fenêtre SDL et d'afficher les trois polices demandées.
	
	
	\newpage
	\section{Les choix}
	Dans cette section, on résumera les différents choix que nous avons fait pour le développement de notre projet. De plus, on essayera d'argumenter certains choix que nous a fait au lieu d'autres possibles. On n'analysera pas en détail toutes nos décisions mais on expliquera les plus importantes. Finalement, on supposera que le lecteur a connaissance des bases mathématiques et informatiques pour comprendre les bases de nos décisions. Par exemple, on n'expliquera pas l'algorithme de Casteljau.
	
	\subsection{L'algorithme de Casteljau}
	Pour la construction de chaque lettre on utilisera des courbes de Bézier linéaires et quadratiques. L'idée générale est d'utiliser des points de contrôle sur un tableau $1 \times 1$ et après le multiplier pour la largeur et la hauteur du bitmap.\\
	
	On a choisi cet algorithme comme était indiqué dans les instructions. L'avantage de cet algorithme est observable pour le cas où la largueur et la hauteur du bitmap n'ont pas la même rélation. Ce qui nous permettra de créer des polices de caractères de différentes tailles. Lié à céla, le choix de décrire des points de contrôle sur un tableau $1 \times 1$ au lieu d'autres tailles aide a simplifier le code. Par exemple, si le tableau était $64 \times 64$ on devrait multiplier la premier cordonée par $\frac{\text{width}}{64}$ pour obtenir la cordonée dans le bitmap.
	
	\subsection{Critère d'arrêt}
	Pour le critère d'arrêt on a choisi de créer un nombre de points égale au maximum du nombre de pixels en hauteur et en largueur. L'idée d'utiliser ce critère au lieu d'un autre est d'avoir  sa taille dans la création de l'objet où on va sauvegarder les valeurs et d'éviter de faire des comparaisons chaque fois qu'on utilise le critère.
	
	\subsection{La représentation des points}
	Pour la représentation des points, on doit transformer des valeurs dans $\mathbb{R}^2$ à $\mathbb{N}^2$ car on travaille sur des pixels. Alors, on a choisi comme forme la transformation de C++ en changent le type de \texttt{float} à \texttt{int}.\\
	
	On a choisi cette méthode pour deux raisons. En premier lieu, la facilité à l'heure de programmer parce que cette méthode nous permet de ne pas créer une autre méthode pour le faire. En deuxième lieu, on sent qu'il est plus rapide car il est implementé directement en C++. Donc, il n'y a pas besoin de le chercher dans un fichier créer par nous mêmes.
	
	\subsection{Le stockage des lettres}
	Afin de stocker des valeurs pour la création de chaque lettre on a crée une fonction par lettre. Après, on a construit une fonction qui, avec l'ASCII value de la lettre appelle à la fonction de ce lettre.\\
	
	Le raison de ce choix vient de la possibilité d'exécuter une lettre de façon indépendante, par exemple, si on sait aupréalable quelle lettre on veut. De plus, le stockage de toutes les valeurs dans la même fonction impliquerait qu'on ait une fonction avec plus de 50 lignes, ce qui était le maximum considéré dans les intructions de notre projet. 
	
	\newpage
	\section{Difficultés techniques}
	Dans cette section on montre les principales difficultés techniques trouvées et notre façon de les résoudre.
	
	\subsection{Le contour}
	On n'a pas une forme simple de faire le contour sans connaître le remplissage interne des lettres avec des courbes, c'est-à-dire, des courbes de Bézier avec trois points de contrôle. Ce problème vient du fait qu'on doit connaître la tangente dans le point mais on connaît le point.\\
	
	La solution qu'on a choisi est de créer l'ensemble du bitmap et de le remplir. Après, si on veut, on  peut créer la police avec le contour noir uniquement dans la classe rélative à la SDL. On sait que cette solution n'est pas optimale mais
	
	\subsection{Utilisation de la SDL}
	Dans une premier partie du projet, on n'était pas capables de réussir à installer la bibliothéque SDL, cela a été résolu dans l'ordinateur d'un des deux membres du binôme. En effet, on a d'abord essayé d'installer la SDL sur macos, sans succès, avant d'essayer sous WSL (Windows Subsystem for Linux). Postérieurement, il aurait été plus simple d'installer directement une distribution linux sans machine virtuelle car l'affichage d'une fenêtre externe, ici la fenêtre SDL, depuis la machine virtuelle pose des problèmes qui sont résolvables en installant un petit logiciel qui permet justement de gérer ces fenêtres. \\
	
	En parallèle, on a décidé de créer une classe auxiliaire appelée Bitmap pour montrer avec des zéros, uns et deux la lettre demandé. Ensuite, lorsque l'on a résolu le problème d'installation de la SDL on a décidé de maintenir la classe crée pour les utilisateur qui voudraint voir le résultat sans pouvoir utiliser la SDL.
	
	\newpage
	\section{Réalisation}
	\subsection{Description des fournitures}
	D'un côté, le répertoire \textbf{src} contient l'ensemble des fichiers .cpp et .h utilisés pour éxecuter le code avec la commande
	\begin{verbatim}
		g++ -g -Wall -Wextra -o projet *.cpp ‘pkg-config --cflags --libs sdl2‘
	\end{verbatim}
	comme est démandé.\\
	
	D'autre côté, le répertoire \textbf{rapport} contient le rapport en pdf et .tex ainsi commee l'ensemble de fichiers nécessaires pour l'exécution du fichier .tex.
	
	\subsection{Synthèse des fonctionnalités remplies}
	Les principales fonctionnalités remplies dans le projet sont:
	\begin{enumerate}
		\item Création d'un bitmap de taille séléctione pour l'utilisateur.
		\item Sélection de lettre majuscule de l'alphabet.
		\item Remplissage du bitmap de trois façons distincts: contour noir, remplissage intérieur ou remplissage intérieur avec contour rouge.
	\end{enumerate}
	
	\newpage
	\section{Conclusions}
	Enfin, on peut conclure qu'on a réussi à réaliser des bitmaps pour les lettres de l'alphabet en majuscule sur un bitmap.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=0.8\linewidth]{Images/lettre_B.png}
		\caption{Lettre B réalisé avec notre code.}
		\label{im:lettreB}
	\end{figure}
	
	On peut voir les trois polices différentes dans la Figure \ref{im:lettreB}. On a le contour en noir de la lettre, le remplissage interne et le remplissage interne avec le contour en rouge pour pouvoir la lire dans tous les cas.
	
	
	\subsection{Améliorations}
	Pour améliorer le projet, on considère deux points principales. En premier lieu, on pourrait continuer avec la création des lettres minuscules ains comme des signes de ponctuation pour être capables d'augmenter nos possibilités d'écriture.\\ 
	
	En deuxième lieu, on pourra considérer l'option d'avoir des bitmaps de la même taille et d'écrire différentes lettres. Cette option permettrait d'écrire mots complets au lieu de lettres et de ne pas à avoir initialiser le programme chaque fois qu'on veut écrire une lettre.
	
\end{document}